# อธิบาย Algorithm การจดจำใบหน้า (Face Recognition)

## สารบัญ
1. [ภาพรวมของระบบ](#1-ภาพรวมของระบบ)
2. [ขั้นตอนการทำงาน](#2-ขั้นตอนการทำงาน)
3. [Algorithm ที่ใช้](#3-algorithm-ที่ใช้)
4. [การเปรียบเทียบใบหน้า](#4-การเปรียบเทียบใบหน้า)
5. [โครงสร้างข้อมูล](#5-โครงสร้างข้อมูล)
6. [คำถามที่อาจารย์อาจถาม](#6-คำถามที่อาจารย์อาจถาม)

---

## 1. ภาพรวมของระบบ

ระบบ Smart Scan Face ใช้เทคโนโลยี **Face Recognition** ในการจดจำใบหน้านักศึกษา โดยใช้ Library หลัก 2 ตัวคือ:

- **dlib** - ไลบรารี C++ สำหรับ Machine Learning และ Computer Vision
- **face_recognition** - Python wrapper ที่ใช้ dlib เป็น backend

### Libraries ที่ใช้:
```python
import face_recognition  # จดจำใบหน้า
import cv2               # OpenCV สำหรับประมวลผลภาพ
import numpy as np       # คำนวณ vector
```

---

## 2. ขั้นตอนการทำงาน

### 2.1 ขั้นตอนการลงทะเบียนใบหน้า (Registration)

```
[รูปภาพ] → [ตรวจจับใบหน้า] → [สร้าง Encoding] → [บันทึกลง Database]
```

1. **รับภาพ** - จากกล้อง webcam หรืออัพโหลดรูปภาพ
2. **ตรวจจับใบหน้า** - ใช้ HOG (Histogram of Oriented Gradients) หาตำแหน่งใบหน้า
3. **สร้าง Face Encoding** - แปลงใบหน้าเป็น vector 128 มิติ
4. **บันทึก** - เก็บ encoding ลงไฟล์ .pkl และข้อมูลลง SQLite

### 2.2 ขั้นตอนการเช็คชื่อ (Verification)

```
[รูปภาพ] → [สร้าง Encoding] → [เปรียบเทียบกับ Database] → [ระบุตัวตน]
```

1. **รับภาพ** - สแกนใบหน้าจากกล้อง
2. **สร้าง Encoding** - แปลงเป็น vector 128 มิติ
3. **เปรียบเทียบ** - คำนวณ Euclidean Distance กับทุกใบหน้าในระบบ
4. **ระบุตัวตน** - เลือกใบหน้าที่ใกล้เคียงที่สุด (ถ้าผ่านเกณฑ์)

---

## 3. Algorithm ที่ใช้

### 3.1 Face Detection - HOG (Histogram of Oriented Gradients)

**หลักการทำงาน:**
- แบ่งภาพออกเป็น cells ขนาดเล็ก (เช่น 8x8 pixels)
- คำนวณ gradient (ทิศทางและความเข้มของขอบ) ในแต่ละ cell
- สร้าง histogram ของทิศทาง gradient
- รวม histograms เป็น feature vector
- ใช้ SVM classifier ตรวจจับว่าเป็นใบหน้าหรือไม่

```python
# โค้ดในระบบ (face_recognition_service.py)
face_locations = face_recognition.face_locations(rgb_image, model="hog")
```

**ทำไมใช้ HOG?**
- เร็วกว่า CNN มาก (ไม่ต้องใช้ GPU)
- ความแม่นยำดีพอสำหรับใบหน้าที่หันตรง
- เหมาะกับการใช้งาน real-time

### 3.2 Face Encoding - Deep Learning (ResNet)

**หลักการทำงาน:**
- ใช้ Deep Neural Network (ResNet) ที่ train มาแล้ว
- Network ถูก train ให้สร้าง vector ที่:
  - **ใบหน้าคนเดียวกัน** → vector คล้ายกัน (distance น้อย)
  - **ใบหน้าคนต่างกัน** → vector ต่างกัน (distance มาก)
- Output เป็น vector 128 มิติ (128-dimensional embedding)

```python
# โค้ดในระบบ
encodings = face_recognition.face_encodings(rgb_image, face_locations)
# ผลลัพธ์: numpy array ขนาด (128,)
```

**ตัวอย่าง Face Encoding:**
```python
# Face encoding คือตัวเลข 128 ตัว เช่น:
[-0.1234, 0.0567, -0.0891, 0.1234, ..., 0.0456]  # 128 ค่า
```

### 3.3 Face Comparison - Euclidean Distance

**หลักการทำงาน:**
- คำนวณระยะห่างระหว่าง 2 vectors (Euclidean Distance)
- ถ้าระยะห่าง < threshold → เป็นคนเดียวกัน

**สูตร Euclidean Distance:**
```
d(A, B) = √[(a₁-b₁)² + (a₂-b₂)² + ... + (a₁₂₈-b₁₂₈)²]
```

```python
# โค้ดในระบบ
distance = face_recognition.face_distance([known_encoding], unknown_encoding)[0]
# distance < 0.6 → ถือว่าเป็นคนเดียวกัน
```

---

## 4. การเปรียบเทียบใบหน้า

### 4.1 Tolerance (ค่าความคลาดเคลื่อนที่ยอมรับ)

```python
FACE_RECOGNITION_TOLERANCE = 0.6  # ค่าเริ่มต้น
```

| Tolerance | ความหมาย |
|-----------|----------|
| 0.4 | เข้มงวดมาก - แม่นยำสูง แต่อาจไม่รู้จักคนที่รู้จัก |
| 0.6 | ค่าเริ่มต้น - สมดุลระหว่างความแม่นยำและความยืดหยุ่น |
| 0.8 | ผ่อนปรน - รู้จักง่าย แต่อาจจำผิดคน |

### 4.2 ขั้นตอนการเปรียบเทียบ

```python
def find_matching_student(unknown_encoding, students):
    best_match = None
    best_distance = float('inf')  # เริ่มต้นที่ระยะห่างมากที่สุด

    for student in students:
        # โหลด encoding ของนักศึกษาจากไฟล์
        known_encoding = load_face_encoding(student['face_encoding_path'])

        # คำนวณระยะห่าง
        distance = face_distance([known_encoding], unknown_encoding)[0]

        # ตรวจสอบว่าผ่านเกณฑ์และดีกว่าที่เคยเจอ
        if distance < TOLERANCE and distance < best_distance:
            best_match = student
            best_distance = distance

    return best_match
```

---

## 5. โครงสร้างข้อมูล

### 5.1 Face Encoding Storage

```
face_data/
├── face_1_20250131_120000.pkl    # encoding ของนักศึกษา ID 1
├── face_2_20250131_120500.pkl    # encoding ของนักศึกษา ID 2
└── face_3_20250131_121000.pkl    # encoding ของนักศึกษา ID 3
```

**ไฟล์ .pkl (Pickle):**
- เก็บ numpy array ขนาด 128 มิติ
- ใช้ Python pickle สำหรับ serialize/deserialize

### 5.2 Database Schema

```sql
-- ตาราง students
CREATE TABLE students (
    id INTEGER PRIMARY KEY,
    student_id TEXT,           -- รหัสนักศึกษา
    first_name TEXT,           -- ชื่อ
    last_name TEXT,            -- นามสกุล
    face_encoding_path TEXT,   -- path ไปยังไฟล์ encoding
    created_at TIMESTAMP
);

-- ตาราง attendance_logs
CREATE TABLE attendance_logs (
    id INTEGER PRIMARY KEY,
    student_id INTEGER,        -- FK ไปยัง students
    class_name TEXT,           -- ชื่อวิชา
    check_in_time TIMESTAMP    -- เวลาเช็คชื่อ
);
```

---

## 6. คำถามที่อาจารย์อาจถาม

### Q1: ทำไม AI ถึงจดจำใบหน้าได้?

**ตอบ:** ระบบใช้ Deep Learning (ResNet) ที่ถูก train มาจากใบหน้าหลายล้านภาพ Network เรียนรู้ที่จะแปลงใบหน้าเป็น vector 128 มิติ โดยที่:
- ใบหน้าคนเดียวกัน → vector คล้ายกัน
- ใบหน้าคนต่างกัน → vector ต่างกัน

### Q2: Face Encoding คืออะไร?

**ตอบ:** Face Encoding คือการแปลงภาพใบหน้าเป็นตัวเลข 128 ตัว (vector 128 มิติ) ที่เป็น "ลายเซ็น" เฉพาะของแต่ละคน ไม่ว่าจะถ่ายรูปกี่ครั้ง vector ที่ได้จะคล้ายกันเสมอ

### Q3: ทำไมใช้ Euclidean Distance?

**ตอบ:** Euclidean Distance คำนวณ "ระยะห่าง" ระหว่าง 2 vectors ในปริภูมิ 128 มิติ ถ้าระยะห่างน้อย (< 0.6) แสดงว่าใบหน้าคล้ายกัน ถ้าระยะห่างมาก (> 0.6) แสดงว่าเป็นคนต่างกัน

### Q4: ถ้ามีคนหน้าคล้ายกันจะทำอย่างไร?

**ตอบ:** ลด tolerance ให้เข้มงวดขึ้น (เช่น จาก 0.6 เป็น 0.4) เพื่อให้ระบบแยกแยะได้ละเอียดขึ้น แต่ข้อเสียคืออาจไม่รู้จักคนที่รู้จักถ้าแสงหรือมุมเปลี่ยน

### Q5: HOG vs CNN ต่างกันอย่างไร?

**ตอบ:**
| | HOG | CNN |
|--|-----|-----|
| ความเร็ว | เร็วมาก | ช้ากว่า |
| ความแม่นยำ | ดี (หันหน้าตรง) | ดีมาก (ทุกมุม) |
| Hardware | CPU ได้ | ต้องการ GPU |

### Q6: ข้อมูลใบหน้าเก็บอย่างไร?

**ตอบ:** ไม่เก็บรูปภาพ! เก็บเฉพาะ Face Encoding (ตัวเลข 128 ตัว) ซึ่งไม่สามารถแปลงกลับเป็นรูปภาพได้ ทำให้ปลอดภัยกว่าการเก็บรูปภาพจริง

### Q7: ระบบรองรับกี่คน?

**ตอบ:** ไม่จำกัด แต่ถ้ามีคนมากขึ้น การค้นหาจะช้าลง เพราะต้องเปรียบเทียบกับทุกคนในระบบ (O(n) complexity)

---

## Flowchart การทำงาน

```
┌──────────────────┐
│   รับภาพจากกล้อง   │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  ตรวจจับใบหน้า    │  ← HOG Algorithm
│  (Face Detection) │
└────────┬─────────┘
         │
         ▼
    ┌────────────┐
    │ พบใบหน้า?  │
    └─────┬──────┘
          │
    ┌─────┴─────┐
    │           │
    ▼           ▼
  [ใช่]       [ไม่]
    │           │
    ▼           ▼
┌──────────┐  ┌────────────┐
│สร้าง      │  │แจ้ง Error   │
│Encoding  │  │ไม่พบใบหน้า │
└────┬─────┘  └────────────┘
     │
     ▼
┌──────────────────┐
│  เปรียบเทียบกับ   │  ← Euclidean Distance
│  ข้อมูลในระบบ     │
└────────┬─────────┘
         │
         ▼
    ┌────────────┐
    │ พบ Match?  │
    │ (d < 0.6)  │
    └─────┬──────┘
          │
    ┌─────┴─────┐
    │           │
    ▼           ▼
  [ใช่]       [ไม่]
    │           │
    ▼           ▼
┌──────────┐  ┌────────────┐
│บันทึก     │  │แจ้ง Error   │
│เช็คชื่อ   │  │ไม่พบในระบบ │
└──────────┘  └────────────┘
```

---

## 7. AI รู้ได้อย่างไรว่าใบหน้านี้คือใคร?

### 7.1 กระบวนการทำงานของการสแกนใบหน้า

เมื่อนักศึกษาสแกนใบหน้า ระบบทำงานดังนี้:

```
1. กล้องถ่ายภาพ → รูปภาพดิจิทัล (pixels)
2. ตรวจจับใบหน้า → หาตำแหน่ง ตา จมูก ปาก คิ้ว (68 จุดสำคัญ)
3. จัดตำแหน่งใบหน้า → หมุนและปรับขนาดให้ตรง
4. สร้าง Encoding → แปลงเป็นตัวเลข 128 ตัว
5. เปรียบเทียบ → หาใบหน้าที่ใกล้เคียงที่สุดในฐานข้อมูล
```

### 7.2 AI จับจากอะไร? (Face Landmarks)

AI ตรวจจับ **68 จุดสำคัญบนใบหน้า** ได้แก่:

| ส่วน | จำนวนจุด | รายละเอียด |
|------|---------|-----------|
| คิ้วซ้าย | 5 จุด | รูปร่างและตำแหน่งคิ้ว |
| คิ้วขวา | 5 จุด | รูปร่างและตำแหน่งคิ้ว |
| ตาซ้าย | 6 จุด | ขนาดและรูปร่างตา |
| ตาขวา | 6 จุด | ขนาดและรูปร่างตา |
| จมูก | 9 จุด | ความยาว ความกว้าง |
| ปาก | 20 จุด | รูปร่างริมฝีปาก |
| ขอบใบหน้า | 17 จุด | รูปทรงใบหน้า |

```python
# ตัวอย่างจุดที่ AI ตรวจจับ
face_landmarks = {
    'chin': [(x1,y1), (x2,y2), ...],      # ขอบคาง
    'left_eyebrow': [...],                 # คิ้วซ้าย
    'right_eyebrow': [...],                # คิ้วขวา
    'nose_bridge': [...],                  # สันจมูก
    'nose_tip': [...],                     # ปลายจมูก
    'left_eye': [...],                     # ตาซ้าย
    'right_eye': [...],                    # ตาขวา
    'top_lip': [...],                      # ริมฝีปากบน
    'bottom_lip': [...]                    # ริมฝีปากล่าง
}
```

### 7.3 ทำไม AI ถึงรู้ว่าเป็นใคร?

AI ไม่ได้ "รู้จัก" ใบหน้าแบบมนุษย์ แต่ใช้หลักการ **เปรียบเทียบความคล้าย**:

1. **ตอนลงทะเบียน**: แปลงใบหน้าเป็นตัวเลข 128 ตัว แล้วบันทึกไว้
2. **ตอนสแกน**: แปลงใบหน้าที่สแกนเป็นตัวเลข 128 ตัว
3. **เปรียบเทียบ**: วัดความต่างระหว่างตัวเลข 2 ชุด
4. **ตัดสิน**: ถ้าต่างกันน้อย (< 0.6) = คนเดียวกัน

**ตัวอย่างง่ายๆ:**
```
นักศึกษา A ลงทะเบียน: [0.12, -0.34, 0.56, ...]  (128 ตัว)
ใบหน้าที่สแกน:        [0.11, -0.35, 0.55, ...]  (128 ตัว)
                           ↓
ความต่าง (distance) = 0.03  ← น้อยกว่า 0.6 = คนเดียวกัน!
```

---

## 8. ปัญหาคนหน้าเหมือนกัน (Similar Faces)

### 8.1 AI แยกแยะได้อย่างไร?

แม้คนจะหน้าคล้ายกัน AI ยังแยกได้เพราะ:

| ลักษณะ | รายละเอียด |
|--------|-----------|
| ระยะห่างระหว่างตา | แต่ละคนต่างกันเล็กน้อย |
| รูปร่างจมูก | ความกว้าง ความยาว มุมต่างๆ |
| ขอบใบหน้า | รูปทรง ความกว้าง |
| ขนาดริมฝีปาก | สัดส่วนต่างกัน |
| ตำแหน่งคิ้ว | ระยะห่างจากตา |

### 8.2 กรณีฝาแฝด (Twins)

**ปัญหา:** ฝาแฝดเหมือนอาจมี encoding ที่คล้ายกันมาก

**วิธีแก้ไข:**
1. **ลด Tolerance** - เปลี่ยนจาก 0.6 เป็น 0.4 หรือต่ำกว่า
2. **ใช้หลายรูป** - ลงทะเบียนหลายมุม หลายแสง
3. **เพิ่มการยืนยัน** - ใช้รหัส PIN ร่วมด้วย

```python
# ในไฟล์ config.py
FACE_RECOGNITION_TOLERANCE = 0.4  # เข้มงวดขึ้นสำหรับกรณีฝาแฝด
```

### 8.3 ตารางเปรียบเทียบ Tolerance

| Tolerance | ใช้กรณี | ข้อดี | ข้อเสีย |
|-----------|--------|------|--------|
| 0.4 | ฝาแฝด/ต้องการความแม่นยำสูง | แยกแยะได้ดี | อาจไม่รู้จักตัวเองถ้าแสงเปลี่ยน |
| 0.5 | ทั่วไป (แนะนำ) | สมดุลดี | - |
| 0.6 | ค่าเริ่มต้น | รู้จักง่าย | อาจจำผิดคนได้ |
| 0.7+ | ไม่แนะนำ | - | เสี่ยงจำผิดคน |

---

## 9. ข้อจำกัดของระบบ

### 9.1 ปัจจัยที่มีผลต่อความแม่นยำ

| ปัจจัย | ผลกระทบ | วิธีแก้ |
|--------|---------|--------|
| **แสงสว่าง** | แสงน้อย/มากเกินไป ทำให้จับใบหน้าไม่ได้ | ใช้ในที่มีแสงเพียงพอ |
| **มุมใบหน้า** | หันข้างมากไป อาจไม่รู้จัก | หันหน้าตรงกล้อง |
| **แว่นตา** | แว่นกันแดดดำอาจบังตา | ถอดแว่นกันแดด |
| **หน้ากาก** | บังส่วนใหญ่ของใบหน้า | ถอดหน้ากาก |
| **การเปลี่ยนแปลง** | ตัดผม ไว้หนวด | ลงทะเบียนใหม่ |

### 9.2 สิ่งที่ AI ไม่สามารถทำได้

- ❌ จดจำได้จากรูปถ่ายในมือถือ (ป้องกัน spoofing)
- ❌ ทำงานในที่มืดสนิท
- ❌ จดจำได้แม่นยำ 100% ทุกกรณี

---

## สรุป

ระบบ Smart Scan Face ใช้หลักการ:

1. **Face Detection** - ใช้ HOG หาตำแหน่งใบหน้า
2. **Face Landmarks** - ตรวจจับ 68 จุดสำคัญบนใบหน้า
3. **Face Encoding** - ใช้ Deep Learning (ResNet) สร้าง vector 128 มิติ
4. **Face Comparison** - ใช้ Euclidean Distance เปรียบเทียบ vectors
5. **Threshold** - ใช้ค่า tolerance 0.6 เป็นเกณฑ์ตัดสิน

**AI รู้ว่าเป็นใครได้อย่างไร?**
- AI แปลงใบหน้าเป็นตัวเลข 128 ตัว (Face Encoding)
- เปรียบเทียบกับตัวเลขที่บันทึกไว้ตอนลงทะเบียน
- ถ้าตัวเลขคล้ายกัน (distance < 0.6) = คนเดียวกัน

**ปัญหาคนหน้าเหมือน:**
- ลด tolerance ให้เข้มงวดขึ้น
- ลงทะเบียนหลายมุม หลายแสง
- เพิ่มการยืนยันตัวตนแบบอื่น (รหัส PIN)

ข้อดีของระบบ:
- ไม่ต้องเก็บรูปภาพจริง (ปลอดภัย)
- ทำงานได้เร็ว (ใช้ HOG)
- แม่นยำพอสมควร (Face Encoding จาก Deep Learning)
